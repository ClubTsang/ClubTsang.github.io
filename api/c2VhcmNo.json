[{"title":"经典排序算法汇总","date":"2020-05-07T16:00:00.000Z","date_formatted":{"ll":"May 8, 2020","L":"05/08/2020","MM-DD":"05-08"},"updated":"2021-05-06T16:09:15.624Z","content":"冒泡排序（Bubble Sort）\n123456789101112131415161718192021222324//冒泡排序 ---&gt; 把数组A,从位置l到位置r进行排序void BubbleSort(int A[], int l, int r)&#123;    if (NULL == A || r - l &lt; 1)    &#123;        return;    &#125;    bool b = true;    for (int end = r; true &amp;&amp; end &gt; l; --end)    &#123;        b = false;        for (int i = l; i &lt; end; ++i)        &#123;            if (A[i] &gt; A[i + 1])            &#123;                b = true;                int temp = A[i];                A[i] = A[i + 1];                A[i + 1] = temp;            &#125;        &#125;    &#125;&#125;\n选择排序（Selction Sort）\n1234567891011121314151617181920212223242526//选择排序 ---&gt; 把数weiz组A,从位置l到位置r进行排序void SelctionSort(int A[], int l, int r)&#123;    if (NULL == A || r - l &lt; 1)    &#123;        return;    &#125;    for (int i = l; i &lt; r; ++i)    &#123;        int minIndex = i;        for (int j = i + 1; j &lt;= r; ++j)        &#123;            if (A[minIndex] &gt; A[j])            &#123;                minIndex = j;            &#125;        &#125;        if (minIndex != i)        &#123;            int temp = A[i];            A[i] = A[minIndex];            A[minIndex] = temp;        &#125;    &#125;&#125;\n插入排序（Insertion Sort）\n12345678910111213141516171819//插入排序 ---&gt; 把数组A,从位置l到位置r进行排序void InsertionSort(int A[], int l, int r)&#123;    if (NULL == A || r - l &lt; 1)    &#123;        return;    &#125;    for (int i = l; i &lt;= r; ++i)    &#123;        int temp = A[i];        int j = i - 1;        for (j; j &gt;= l &amp;&amp; temp &lt; A[j]; --j)        &#123;            A[j + 1] = A[j];        &#125;        A[j + 1] = temp;    &#125;&#125;\n希尔排序（Shell Sort）\n12345678910111213141516171819202122232425262728/** * 希尔排序 * 希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。 * */void ShellSort(int A[], int l, int r)&#123;    if (NULL == A || r - l &lt; 1)    &#123;        return;    &#125;    int size = r - l + 1;    int gap = size / 2;    while (gap &gt; 0)    &#123;        for (int i = l + gap; i &lt;= r; ++i)        &#123;            int j = i;            int temp = A[j];            for (j; j - gap &gt;= l &amp;&amp; A[j - gap] &gt; temp; j -= gap)            &#123;                A[j] = A[j - gap];            &#125;            A[j] = temp;        &#125;        gap /= 2;    &#125;&#125;\n快速排序（Quick Sort）\n12345678910111213141516171819202122232425262728293031//快速排序 ---&gt; 把数组A,从位置l到位置r进行排序void QuickSort(int A[], int l, int r)&#123;    if (l &lt; r &amp;&amp; NULL != A)    &#123;        int low = l, high = r;        int target = A[l];        while (low &lt; high)        &#123;            while (low &lt; high &amp;&amp; A[high] &gt;= target)            &#123;                --high;            &#125;            if (low &lt; high)            &#123;                A[low++] = A[high];            &#125;            while (low &lt; high &amp;&amp; A[low] &lt;= target)            &#123;                ++low;            &#125;            if (low &lt; high)            &#123;                A[high--] = A[low];            &#125;        &#125;        A[low] = target;        QuickSort(A, l, low - 1);        QuickSort(A, high + 1, r);    &#125;&#125;\n12345678910111213141516171819202122232425262728293031323334//快速排序之基于荷兰国旗排序改进 ---&gt; 把数组A,从位置l到位置r进行排序void QuickSort_Improve(int A[], int l, int r)&#123;    //基于荷兰国旗排序的改进的快速排序    if (l &lt; r &amp;&amp; NULL != A)    &#123;        int low = l - 1;        int high = r + 1;        int cur = l;        int target = A[cur];        while (cur &lt; high)        &#123;            while (cur &lt; high &amp;&amp; A[cur] == target)            &#123;                ++cur;            &#125;            if (cur &lt; high &amp;&amp; A[cur] &lt; target)            &#123;                A[++low] = A[cur];                A[cur++] = target;                continue;            &#125;            if (cur &lt; high &amp;&amp; A[cur] &gt; target)            &#123;                int temp = A[--high];                A[high] = A[cur];                A[cur] = temp;            &#125;        &#125;        QuickSort_Improve(A, l, low);        QuickSort_Improve(A, high, r);    &#125;&#125;\n堆排序（Heap Sort）\n12345678910111213141516171819202122232425262728293031//堆排序 ---&gt; 把数组A,从位置l到位置r进行排序void HeapSort(int A[], int n)&#123;    if (NULL == A || n &lt; 2)    &#123;        return;    &#125;    for (int end = n - 1; end &gt; 0; --end)    &#123;        int temp;        for (int i = (end + 1) / 2 - 1; i &gt;= 0; --i)        &#123;            if (2 * i + 2 &lt;= end &amp;&amp; A[2 * i + 2] &gt; A[i])            &#123;                temp = A[i];                A[i] = A[2 * i + 2];                A[2 * i + 2] = temp;            &#125;            if (A[2 * i + 1] &gt; A[i])            &#123;                temp = A[i];                A[i] = A[2 * i + 1];                A[2 * i + 1] = temp;            &#125;        &#125;        temp = A[0];        A[0] = A[end];        A[end] = temp;    &#125;&#125;\n归并排序（Merge Sort）\n123456789101112131415161718192021222324252627282930313233343536373839404142//归并 ---&gt; 把数组A,从位置l到位置r进行归并void Merge_1(int A[], int l, int mid, int r)&#123;    if (NULL == A || l &gt;= r)    &#123;        return;    &#125;    int *help = new int[r - l + 1];    int i = 0;    int low = l;    int high = mid + 1;    while (low &lt;= mid &amp;&amp; high &lt;= r)    &#123;        help[i++] = A[low] &lt; A[high] ? A[low++] : A[high++];    &#125;    while (low &lt;= mid)    &#123;        help[i++] = A[low++];    &#125;    while (high &lt;= r)    &#123;        help[i++] = A[high++];    &#125;    for (i = 0; i &lt; r - l + 1; i++)    &#123;        A[l + i] = help[i];    &#125;    delete help;    help = NULL;&#125;//归并排序 ---&gt; 递归实现 ---&gt; 把数组A,从位置l到位置r进行排序void MergeSort_1(int A[], int l, int r)&#123;    if (l &lt; r)    &#123;        int mid = l + (r - l) / 2;        MergeSort_1(A, l, mid);        MergeSort_1(A, mid + 1, r);        Merge_1(A, l, mid, r);    &#125;&#125;","thumbnail":"/static/img/articles/00001.jpg","plink":"https://TOPUBLICZX.GITHUB.IO/2020/05/08/经典排序算法/"},{"title":"二叉树（Binary tree）序列化与反序列化","date":"2020-08-07T16:00:00.000Z","date_formatted":{"ll":"Aug 8, 2020","L":"08/08/2020","MM-DD":"08-08"},"updated":"2021-05-06T16:20:09.315Z","content":"1、定义\n1234567//二叉树定义typedef struct BinaryNode&#123;    int val;    struct BinaryNode *left;    struct BinaryNode *right;&#125; BinaryNode, *BinaryTree;\n2、序列化\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//通过前序遍历序列化二叉树char *SerializeByPreOrder(BinaryNode *root)&#123;    if (root == NULL)    &#123;        char *temp = (char *)malloc(2 * sizeof(char));        strcpy(temp, &quot;#,&quot;);        return temp;    &#125;    //int to char*    char ch[16] = &#123;0&#125;;    sprintf(ch,&quot;%d&quot;,root-&gt;val);    strcat(ch, &quot;,&quot;);    char *left = SerializeByPreOrder(root-&gt;left);    char *right = SerializeByPreOrder(root-&gt;right);    int len1 = strlen(ch) + strlen(left) + strlen(right) + 2;    char *result = (char *)malloc(len1 * sizeof(char));    strcpy(result, ch);    strcat(result, left);    strcat(result, right);    //释放内存空间    free(left);    free(right);    left = right = NULL;    return result;&#125;//通过前序遍历序反列化二叉树BinaryNode *DeserializeByPreOrder(char **str)&#123;    if (*(*str) == &#x27;#&#x27;)    &#123;        (*str) += 2;        return NULL;    &#125;    char ch[16] = &#123;0&#125;;    int i = 0;    while (*(*str) != &#x27;,&#x27;)    &#123;        ch[i++] = (*(*str));        ++(*str);    &#125;    ++(*str);        int value =strtol(ch,&#x27;\\0&#x27;,10);        BinaryNode *root = (BinaryNode *)malloc(sizeof(BinaryNode));    root-&gt;val = value;    root-&gt;left = root-&gt;right = NULL;    root-&gt;left = DeserializeByPreOrder(str);    root-&gt;right = DeserializeByPreOrder(str);    return root;&#125;\n3、反序列化\n12345678910111213141516171819202122232425262728//通过前序遍历反序列化二叉树BinaryNode *DeserializeByPreOrder(char **str)&#123;    if (*(*str) == &#x27;#&#x27;)    &#123;        (*str) += 2;        return NULL;    &#125;    char ch[16] = &#123;0&#125;;    int i = 0;    while (*(*str) != &#x27;,&#x27;)    &#123;        ch[i++] = (*(*str));        ++(*str);    &#125;    ++(*str);        int value =strtol(ch,&#x27;\\0&#x27;,10);        BinaryNode *root = (BinaryNode *)malloc(sizeof(BinaryNode));    root-&gt;val = value;    root-&gt;left = root-&gt;right = NULL;    root-&gt;left = DeserializeByPreOrder(str);    root-&gt;right = DeserializeByPreOrder(str);    return root;&#125;\n4、完整代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;//二叉树定义typedef struct BinaryNode&#123;    int val;    struct BinaryNode *left;    struct BinaryNode *right;&#125; BinaryNode, *BinaryTree;//通过前序遍历序列化二叉树char *SerializeByPreOrder(BinaryNode *root);//通过前序遍历反序列化二叉树BinaryNode *DeserializeByPreOrder(char **str);//释放二叉树内存空间void FreeBinaryTree(BinaryNode *root);//测试函数void test()&#123;    //前序遍历序列化二叉树    char ch[] = &quot;1,2,#,-3,4,#,#,5,#,#,-8,9,#,#,21,-23,#,#,-24,#,#,&quot;;    /**     *                                      1     *                                    /    \\     *                                   2     -8     *                                    \\     /  \\     *                                    -3   9    21     *                                   /   \\     /   \\     *                                  4     5   -23   24     * */    char *str = (char *)malloc(sizeof(ch) / sizeof(ch[0]));    strcpy(str, ch);    char *strDel = str;    //反序列化生成二叉树    BinaryNode *root = DeserializeByPreOrder(&amp;str);    printf(&quot;Binary tree generated successfully \\n&quot;);    //序列化二叉树    char *res = SerializeByPreOrder(root);    printf(&quot;Binary tree Serialize successfully \\n&quot;);    printf(&quot;%s \\n&quot;, res);    //释放空间内存    free(res);    free(strDel);    FreeBinaryTree(root);    res = strDel = NULL;&#125;int main()&#123;    test();    return 0;&#125;//通过前序遍历序列化二叉树char *SerializeByPreOrder(BinaryNode *root)&#123;    if (root == NULL)    &#123;        char *temp = (char *)malloc(2 * sizeof(char));        strcpy(temp, &quot;#,&quot;);        return temp;    &#125;    //int to char*    char ch[16] = &#123;0&#125;;    sprintf(ch,&quot;%d&quot;,root-&gt;val);    strcat(ch, &quot;,&quot;);    char *left = SerializeByPreOrder(root-&gt;left);    char *right = SerializeByPreOrder(root-&gt;right);    int len1 = strlen(ch) + strlen(left) + strlen(right) + 2;    char *result = (char *)malloc(len1 * sizeof(char));    strcpy(result, ch);    strcat(result, left);    strcat(result, right);    //释放内存空间    free(left);    free(right);    left = right = NULL;    return result;&#125;//通过前序遍历反序列化二叉树BinaryNode *DeserializeByPreOrder(char **str)&#123;    if (*(*str) == &#x27;#&#x27;)    &#123;        (*str) += 2;        return NULL;    &#125;    char ch[16] = &#123;0&#125;;    int i = 0;    while (*(*str) != &#x27;,&#x27;)    &#123;        ch[i++] = (*(*str));        ++(*str);    &#125;    ++(*str);        int value =strtol(ch,&#x27;\\0&#x27;,10);        BinaryNode *root = (BinaryNode *)malloc(sizeof(BinaryNode));    root-&gt;val = value;    root-&gt;left = root-&gt;right = NULL;    root-&gt;left = DeserializeByPreOrder(str);    root-&gt;right = DeserializeByPreOrder(str);    return root;&#125;//释放二叉树内存空间void FreeBinaryTree(BinaryNode *root)&#123;    if (root == NULL)    &#123;        return;    &#125;    BinaryNode *left = root-&gt;left;    BinaryNode *right = root-&gt;right;    free(root);    root = NULL;    FreeBinaryTree(left);    FreeBinaryTree(right);&#125;\n","thumbnail":"/static/img/articles/00002.jpg","plink":"https://TOPUBLICZX.GITHUB.IO/2020/08/08/二叉树序列化与反序列化/"},{"title":"友情链接","date":"2019-12-31T16:00:00.000Z","date_formatted":{"ll":"Jan 1, 2020","L":"01/01/2020","MM-DD":"01-01"},"updated":"2021-05-17T07:50:39.081Z","content":"\n友链网站：\n\nLeetCode\n牛客网\nVijos\n洛谷\nAcWing\n信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)\nDBeaver Community | Free Universal Database Tool\n100个C语言经典小程序和C语言编写的小游戏，带注释和解析_C语言中文网 (biancheng.net)\nC++入门教程，全套C++基础教程（已更新完毕）_微学苑(编程第一站) (weixueyuan.net)\nRed Blob Games\n\n\n","plink":"https://TOPUBLICZX.GITHUB.IO/link/"},{"title":"1862.Excel排序","date":"2020-04-30T16:00:00.000Z","date_formatted":{"ll":"May 1, 2020","L":"05/01/2020","MM-DD":"05-01"},"updated":"2021-05-06T17:30:10.202Z","content":"1、Problem Description\n1Excel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。\n2、Input\n123456测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。\n3、Output\n12345对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。\n4、Sample Input\n1234567891011121314153 1000007 James 85000010 Amy 90000001 Zoe 604 2000007 James 85000010 Amy 90000001 Zoe 60000002 James 984 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 900 0\n5、Sample Output\n1234567891011121314Case 1:000001 Zoe 60000007 James 85000010 Amy 90Case 2:000010 Amy 90000002 James 98000007 James 85000001 Zoe 60Case 3:000001 Zoe 60000007 James 85000002 James 90000010 Amy 90\n6、Submit\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;struct Student&#123;    char SNO[7];    char SNAME[9];    int GRADE;&#125;;struct Student S[100000];void MyInput(int i)&#123;    cin&gt;&gt;S[i].SNO&gt;&gt;S[i].SNAME&gt;&gt;S[i].GRADE;&#125;void MyOutput(int i)&#123;    cout &lt;&lt; S[i].SNO &lt;&lt; &quot; &quot; &lt;&lt; S[i].SNAME &lt;&lt; &quot; &quot; &lt;&lt; S[i].GRADE &lt;&lt; endl;&#125;void MySort(int N, int C)&#123;    if (N &lt; 1 || N &gt; 100000)    &#123;        return;    &#125;    if (C == 1)    &#123;        sort(S, S + N, [](struct Student &amp;s1, struct Student &amp;s2) &#123;            return strcmp(s1.SNO, s2.SNO) &lt; 0;        &#125;);        return;    &#125;    if (C == 2)    &#123;        sort(S, S + N, [](struct Student &amp;s1, struct Student &amp;s2) &#123;            int cmp = strcmp(s1.SNAME, s2.SNAME);            return cmp &lt; 0 || cmp == 0 &amp;&amp; strcmp(s1.SNO, s2.SNO) &lt; 0;        &#125;);        return;    &#125;    if (C == 3)    &#123;        sort(S, S + N, [](struct Student &amp;s1, struct Student &amp;s2) &#123;            return s1.GRADE &lt; s2.GRADE || s1.GRADE == s2.GRADE &amp;&amp; strcmp(s1.SNO, s2.SNO) &lt; 0;        &#125;);        return;    &#125;&#125;int main()&#123;    int N = 1, C;    int index = 1;    while (N)    &#123;        cin &gt;&gt; N &gt;&gt; C;        if (N &lt; 1 || N &gt; 100000)        &#123;            break;        &#125;        for (int i = 0; i &lt; N; ++i)        &#123;            MyInput(i);        &#125;        MySort(N, C);                cout &lt;&lt; &quot;Case &quot; &lt;&lt; index++ &lt;&lt; &quot;:&quot; &lt;&lt; endl;                for (int j = 0; j &lt; N; ++j)        &#123;            MyOutput(j);        &#125;    &#125;&#125;\n","thumbnail":"/static/img/articles/00003.jpg","plink":"https://TOPUBLICZX.GITHUB.IO/notes/hduoj/1862-Excel排序/"},{"title":"Note刷题笔记","date":"2021-05-04T17:51:50.366Z","date_formatted":{"ll":"May 5, 2021","L":"05/05/2021","MM-DD":"05-05"},"updated":"2021-05-04T17:51:50.366Z","content":"LeetCode  |  HduOJ   |  左神笔记\n\n1862.Excel排序\n","plink":"https://TOPUBLICZX.GITHUB.IO/notes/hduoj/"},{"title":"Note刷题笔记","date":"2021-05-14T15:39:55.165Z","date_formatted":{"ll":"May 14, 2021","L":"05/14/2021","MM-DD":"05-14"},"updated":"2021-05-04T17:53:04.020Z","content":"LeetCode  |  HduOJ   |  左神笔记\n\n暂无LeetCode笔记\n","plink":"https://TOPUBLICZX.GITHUB.IO/notes/leetcode/"},{"title":"绳子最多能覆盖其中的几个点","date":"2020-05-04T16:00:00.000Z","date_formatted":{"ll":"May 5, 2020","L":"05/05/2020","MM-DD":"05-05"},"updated":"2021-05-06T17:40:17.608Z","content":"1、问题描述\n12给定一个有序数组arr,代表数轴上从左到右有n个点arr[0]、 arr[1]...arr[n－ 1],给定一个正数L， 代表一根长度为L的绳子， 求绳子最多能覆盖其中的几个点。\n2、例子\n123v=[1,3,7,9,13,14,16]L=5result=3\n3、暴力解法\n12345678910111213141516171819//暴力解法O(n*n)，空间复杂度O(1)int coverMaxPoint_1(const vector&lt;int&gt; v, double L)&#123;    if (v.empty() || L &lt;= 0)    &#123;        return 0;    &#125;    int res = 1, size = v.size();    for (int i = 1; i &lt; size; ++i)    &#123;        int j = 0;        while (j &lt; i &amp;&amp; (double)v[j] &lt; (double)v[i] - L)        &#123;            ++j;        &#125;        res = max(res, i - j + 1);    &#125;    return res;&#125;\n4、二分查找思想解法\n123456789101112131415161718192021222324252627282930313233343536//在数组v中，从 0---&gt;n 找到值大于等于target的下标最小值int nearestIndex(const vector&lt;int&gt; v, int n, double target)&#123;    int begin = 0, end = n;    int index = 0;    while (begin &lt; end)    &#123;        int mid = begin + (end - begin) / 2;        if ((double)v[mid] &gt;= target)        &#123;            end = mid - 1;            index = mid;        &#125;        else        &#123;            begin = mid + 1;        &#125;    &#125;    return index;&#125;//通过二分查找优化,时间复杂度O(n*logn)，空间复杂度O(1)int coverMaxPoint_2(const vector&lt;int&gt; v, double L)&#123;    if (v.empty() || L &lt;= 0)    &#123;        return 0;    &#125;    int res = 1;    int size = v.size();    for (int i = 1; i &lt; size; ++i)    &#123;        res = max(res, i + 1 - nearestIndex(v, i, (double)v[i] - L));    &#125;    return res;&#125;\n5、滑动窗口思想解法\n1234567891011121314151617181920212223242526//滑动窗口的思想，时间复杂度O(n),空间复杂度O(1)int coverMaxPoint_3(const vector&lt;int&gt; v, double L)&#123;    if (v.empty() || L &lt;= 0)    &#123;        return 0;    &#125;    int res = 1;    int low = 0, high = 1, size = v.size();    while (high &lt; size)    &#123;        if ((double)(v[high] - v[low]) &lt;= L)        &#123;            ++high;        &#125;        else        &#123;            ++low;        &#125;        if (high &lt; size)        &#123;            res = max(res, high - low + 1);        &#125;    &#125;    return res;&#125;\n","thumbnail":"/static/img/articles/00004.jpg","plink":"https://TOPUBLICZX.GITHUB.IO/notes/zuoshen/CoverMaxPoint/"},{"title":"小和问题","date":"2020-05-04T16:00:00.000Z","date_formatted":{"ll":"May 5, 2020","L":"05/05/2020","MM-DD":"05-05"},"updated":"2021-05-06T17:40:00.446Z","content":"1、Description\n1在一个数组中， 每一个数左边比当前数小的数累加起来， 叫做这个数组的小和。求一个数组的小和。\n2、Example\n1234567[1,3,4,2,5]1左边比1小的数， 没有；3左边比3小的数， 1；4左边比4小的数， 1、 3；2左边比2小的数， 1；5左边比5小的数， 1、 3、 4、 2；所以小和为：1+1+3+1+1+3+4+2=16\n3、Code\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//小和问题 ---&gt; 暴力解法int getSmallSum_1(int A[], int n)&#123;    if (NULL == A || n &lt; 2)    &#123;        return 0;    &#125;    int res = 0;    for (int i = 0; i &lt; n; ++i)    &#123;        for (int j = i + 1; j &lt; n; ++j)        &#123;            if (A[i] &lt; A[j])            &#123;                res += A[i];            &#125;        &#125;    &#125;    return res;&#125;//小和问题 ---&gt; 归并排序思想解决int getSmallSum_2(int A[], int l, int r)&#123;    if (NULL == A || l &gt;= r)    &#123;        return 0;    &#125;    int mid = l + (r - l) / 2;    int res = getSmallSum_2(A, l, mid) + getSmallSum_2(A, mid + 1, r);    //归并    int p1 = l, p2 = mid + 1, i = 0;    int *help = new int[r - l + 1];    while (p1 &lt;= mid &amp;&amp; p2 &lt;= r)    &#123;        res += (A[p1] &lt; A[p2] ? (r - p2 + 1) * A[p1] : 0);        help[i++] = A[p1] &lt; A[p2] ? A[p1++] : A[p2++];    &#125;    while (p1 &lt;= mid)    &#123;        help[i++] = A[p1++];    &#125;    while (p2 &lt;= r)    &#123;        help[i++] = A[p2++];    &#125;    for (i = 0; i &lt; r - l + 1; ++i)    &#123;        A[l + i] = help[i];    &#125;    delete help;    help = NULL;    return res;&#125;\n4、Sumbit\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;time.h&gt;using namespace std;//小和问题 ---&gt; 暴力解法int getSmallSum_1(int A[], int n)&#123;    if (NULL == A || n &lt; 2)    &#123;        return 0;    &#125;    int res = 0;    for (int i = 0; i &lt; n; ++i)    &#123;        for (int j = i + 1; j &lt; n; ++j)        &#123;            if (A[i] &lt; A[j])            &#123;                res += A[i];            &#125;        &#125;    &#125;    return res;&#125;//小和问题 ---&gt; 归并排序思想解决int getSmallSum_2(int A[], int l, int r)&#123;    if (NULL == A || l &gt;= r)    &#123;        return 0;    &#125;    int mid = l + (r - l) / 2;    int res = getSmallSum_2(A, l, mid) + getSmallSum_2(A, mid + 1, r);    //归并    int p1 = l, p2 = mid + 1, i = 0;    int *help = new int[r - l + 1];    while (p1 &lt;= mid &amp;&amp; p2 &lt;= r)    &#123;        res += (A[p1] &lt; A[p2] ? (r - p2 + 1) * A[p1] : 0);        help[i++] = A[p1] &lt; A[p2] ? A[p1++] : A[p2++];    &#125;    while (p1 &lt;= mid)    &#123;        help[i++] = A[p1++];    &#125;    while (p2 &lt;= r)    &#123;        help[i++] = A[p2++];    &#125;    for (i = 0; i &lt; r - l + 1; ++i)    &#123;        A[l + i] = help[i];    &#125;    delete help;    help = NULL;    return res;&#125;//打印数组函数void MyPrintfArray(int A[], int n);//判断两个数组是否相等bool ArrayIsEqual(int A[], int B[], int n);//测试函数void test();int main()&#123;    test();    return 0;&#125;void test()&#123;    int A[20], B[20], C[20];    int count = 0;    int n;    bool b = true;    srand((unsigned)time(NULL));    int res1 = 0, res2 = 0;    while (count &lt; 500000 &amp;&amp; b)    &#123;        ++count;        n = rand() % 5 + 10;        int RandomNumber;        for (int i = 0; i &lt; n; ++i)        &#123;            RandomNumber = rand() % 100 + 1;            A[i] = B[i] = C[i] = RandomNumber;        &#125;        res1 = getSmallSum_1(B, n);        sort(B, B + n);        res2 = getSmallSum_2(C, 0, n - 1);        b = ArrayIsEqual(B, C, n) &amp;&amp; res1 == res2;    &#125;    if (b)    &#123;        cout &lt;&lt; &quot;Success&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;Unsuccess&quot; &lt;&lt; endl;        MyPrintfArray(A, n);        MyPrintfArray(B, n);        MyPrintfArray(C, n);        cout &lt;&lt; &quot;[res1:&quot; &lt;&lt; res1 &lt;&lt; &quot;   res2:&quot; &lt;&lt; res2 &lt;&lt; &quot;]&quot; &lt;&lt; endl;    &#125;&#125;//打印数组函数void MyPrintfArray(int A[], int n)&#123;    if (NULL == A || n &lt; 1)    &#123;        return;    &#125;    for (int i = 0; i &lt; n; ++i)    &#123;        if (i == 0)        &#123;            cout &lt;&lt; &quot;[&quot;;        &#125;        cout &lt;&lt; A[i];        if (i == n - 1)        &#123;            cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;        &#125;        else        &#123;            cout &lt;&lt; &quot;,&quot;;        &#125;    &#125;&#125;//判断两个数组是否相等bool ArrayIsEqual(int A[], int B[], int n)&#123;    if (NULL == A &amp;&amp; NULL != B)    &#123;        return false;    &#125;    if (NULL == B &amp;&amp; NULL != A)    &#123;        return false;    &#125;    for (int i = 0; i &lt; n; ++i)    &#123;        if (A[i] != B[i])        &#123;            return false;        &#125;    &#125;    return true;&#125;\n","thumbnail":"/gallery/articles/00005.jpg","plink":"https://TOPUBLICZX.GITHUB.IO/notes/zuoshen/MinSum/"},{"title":"最小使用多少袋子。","date":"2020-05-04T16:00:00.000Z","date_formatted":{"ll":"May 5, 2020","L":"05/05/2020","MM-DD":"05-05"},"updated":"2021-05-06T17:39:28.991Z","content":"1、Problem Description\n12345小虎去附近的商店买苹果， 奸诈的商贩使用了捆绑交易， 只提供6个每袋和8个每袋的包装包装不可拆分。 可是小虎现在只想购买恰好n个苹果， 小虎想购买尽量少的袋数方便携带。 如果不能购买恰好n个苹果， 小虎将不会购买。 输入一个整数n， 表示小虎想购买的个苹果， 返回最小使用多少袋子。 如果无论如何都不能正好装下， 返回-1。\n2、Sample\n1234567891011121314n=0result=0n=1result=-1n=-10result=-1n=6result=1n=14result=1\n3、解法1\n12345678910111213141516171819202122232425262728293031323334int minUseBag(int n)&#123;    if (n &lt; 5 || n % 2 == 1)    &#123;        return n == 0 ? 0 : -1;    &#125;    int bag8 = n / 8;    int bag6 = 0;    while (bag8 &gt;= 0)    &#123;        for (int i = 0; i &lt; 4; ++i)        &#123;            //防止溢出            if (bag8 &gt; n / 8)            &#123;                return -1;            &#125;            if (bag8 * 8 + i * 6 == n)            &#123;                return bag8 + i;            &#125;        &#125;        --bag8;        ++bag6;        //当剩余的数大于等于6和8的最小公倍数时说明找不到        // n - bag8 * 8 &gt;= 24 改写为n / 8 - bag8 &gt;= 3是防止溢出        if (n / 8 - bag8 &gt;= 3)        &#123;            return -1;        &#125;    &#125;    return -1;&#125;\n4、解法2\n1234567891011121314151617181920212223242526272829//通过解法1发现规律的测试函数void test()&#123;    //根据打印出来的数字得到一个规律;    //当n&lt;0时为-1    //当n==0时，为0    //当n&lt;18时，n=6,8 结果为1 n=12,14,16为2,其他都为-1    //当18&lt;=n&lt;26,偶数为3，奇数为-1    //当26&lt;=n&lt;34，偶数为4，奇数为-1    //所以任意n&gt;=18，偶数为(n-18)/8+3，奇数为-1    for (int i = -1; i &lt; 100; ++i)    &#123;        cout &lt;&lt; i &lt;&lt; &quot;:   &quot; &lt;&lt; minUseBag_1(i) &lt;&lt; endl;    &#125;&#125;//根据下面函数test发现的规律int minUseBag_1(int n)&#123;    int res = -1;    if (n &lt; 18 || n % 2 == 1)    &#123;        res = (n == 0) ? 0 : res;        res = (n == 6 || n == 8) ? 1 : res;        res = (n == 12 || n == 14 || n == 16) ? 2 : res;        return res;    &#125;    return (n - 18) / 8 + 3;&#125;\n","thumbnail":"/static/img/articles/00006.jpg","plink":"https://TOPUBLICZX.GITHUB.IO/notes/zuoshen/MinUseBag/"},{"title":"Note刷题笔记","date":"2021-05-06T17:42:29.680Z","date_formatted":{"ll":"May 7, 2021","L":"05/07/2021","MM-DD":"05-07"},"updated":"2021-05-06T17:41:52.011Z","content":"LeetCode  |  HduOJ   |  左神笔记\n\n小和问题\n绳子最多能覆盖其中的几个点\n最小使用多少袋子\n","plink":"https://TOPUBLICZX.GITHUB.IO/notes/zuoshen/"}]